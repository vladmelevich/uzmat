# Асинхронные оптимизации Uzmat

## Реализованная асинхронность

### 1. Фоновые задачи через threading

Создан модуль `uzmat/utils/background_tasks.py` с функциями для асинхронного выполнения задач:

#### `run_in_background(func, *args, **kwargs)`
Универсальная функция для запуска задач в фоновом потоке. Не блокирует основной запрос.

#### `bump_ads_async()`
- **Что делает**: Автоподнятие объявлений каждые 3 часа
- **Где используется**: Главная страница (`index()`)
- **Преимущество**: Не блокирует загрузку страницы, выполняется в фоне

#### `increment_ad_views_async(ad_id, user_ip)`
- **Что делает**: Увеличение счетчика просмотров объявления
- **Где используется**: Страница детального просмотра (`ad_detail()`)
- **Преимущество**: Пользователь получает ответ сразу, счетчик обновляется в фоне

#### `update_unread_count_cache_async(user_id, unread_count)`
- **Что делает**: Обновление кэша непрочитанных сообщений
- **Где используется**: Главная страница (`index()`)
- **Преимущество**: Кэш обновляется асинхронно, не замедляет ответ

### 2. Оптимизированные операции

#### Автоподнятие объявлений
**До**: Выполнялось синхронно при каждом запросе главной страницы
**После**: Запускается в фоновом потоке, не блокирует ответ

```python
# Старый код (синхронный)
bump_candidates = list(...)
if bump_candidates:
    Advertisement.objects.filter(...).update(...)

# Новый код (асинхронный)
run_in_background(bump_ads_async)
```

#### Счетчики просмотров
**До**: Обновление блокировало ответ страницы
**После**: Обновление в фоне, пользователь получает ответ сразу

```python
# Старый код (синхронный)
ad.views_count += 1
ad.save(update_fields=['views_count'])

# Новый код (асинхронный)
run_in_background(increment_ad_views_async, ad.id, user_ip)
```

## Преимущества асинхронности

1. **Быстрый отклик**: Пользователь получает ответ сразу, тяжелые операции выполняются в фоне
2. **Масштабируемость**: Сайт может обрабатывать больше запросов одновременно
3. **Производительность**: Не блокирующие операции не замедляют основной поток
4. **Надежность**: Ошибки в фоновых задачах не влияют на основной запрос

## Обработка ошибок

Все фоновые задачи обернуты в try-except блоки:
- Ошибки логируются, но не прерывают работу сайта
- Пользователь всегда получает ответ, даже если фоновая задача упала

## Производительность

### Ожидаемые улучшения:
- **Время ответа главной страницы**: -30-50% (за счет асинхронного автоподнятия)
- **Время ответа страницы объявления**: -20-40% (за счет асинхронного счетчика)
- **Пропускная способность**: +40-60% (больше одновременных запросов)

## Дальнейшие улучшения (опционально)

### Celery для сложных задач
Для более сложных фоновых задач можно использовать Celery:

```python
# Установка
pip install celery redis

# Пример задачи
@celery_app.task
def send_email_async(user_id, subject, message):
    # Отправка email
    pass
```

### Django async views
Для Django 3.1+ можно использовать async views:

```python
async def async_index(request):
    # Асинхронные операции
    pass
```

### WebSockets для real-time
Для real-time обновлений (чаты, уведомления) можно использовать WebSockets:
- Django Channels
- WebSocket соединения для чатов

## Мониторинг

Рекомендуется мониторить:
- Количество запущенных фоновых потоков
- Время выполнения фоновых задач
- Ошибки в логах фоновых задач

## Безопасность

- Фоновые потоки не имеют доступа к request объекту после завершения основного запроса
- Все операции с БД выполняются в отдельных транзакциях
- Кэширование предотвращает дублирование операций

